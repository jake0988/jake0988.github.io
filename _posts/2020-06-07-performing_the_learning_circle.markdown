---
layout: post
title:      "Performing the learning circle"
date:       2020-06-08 03:54:51 +0000
permalink:  performing_the_learning_circle
---


Learning to program, just like learning to do most things that are interesting, is difficult and rewarding. With every new concept that is introduced, I try to understand what each word means in the context in which it is given. This in itself can be very challenging, because the way things need to be phrased when teaching programming, much like when learning math, is not necessarily intuitively comprehensible for me. Sometimes I go over the sentence many times, often repeating it outloud, hoping to understand the gist of it. And sometimes even this conceptual understanding fails. But that isn't really a problem. Unlike in math, I can just start writing the program and testing it to see what it actually does. When I am able to see the results of my program, sometimes stopping in multiple stages of the program to really see the inside of the concept I am trying to understand, the image begins to form about what it is I am learning about. When I go back to the words that were teaching the concept in the first place, all of a sudden they begin to make sense. Then, the more I use the concept later on, the easier it is for me to work with.

Pacing is one of the hardest things for me to get a handle on. How fast should I move through each section or each concept? This is one of the greatest pitfalls of self-paced learning. When given a teacher who knows the importance of each topic I am learning, and the level of understanding which I have, I can be guided at a pace which would best suit me. Also, with peers who are learning the same material at the same time I could gauge how well I am learning and what I may need more understanding of. But self pacing is in itself a skill that if mastered can afford great benefits. Particularly in programming, which is a curriculum that is constantly changing and expanding. Self pacing is an essential skill, and the more aware I am of what is a successful strategy in how I am learning to program, the better a programmer I'll be.
